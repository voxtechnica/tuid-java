package info.voxtechnica.tuid;

import org.junit.jupiter.api.Test;

import java.math.BigInteger;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

public class TUIDTest {

    @Test
    public void tuidsSortChronologically() {
        TUID tuid1 = new TUID();
        TUID tuid2 = new TUID();
        assertTrue(tuid1.compareTo(tuid2) < 0);
        assertTrue(tuid1.toString().compareTo(tuid2.toString()) < 0);
    }

    @Test
    public void tuidInstantIsPreserved() {
        Instant now = Instant.now();
        TUID tuid1 = new TUID(now);
        TUID tuid2 = new TUID(tuid1.getId());
        assertEquals(now, TUID.createdAt(tuid1.getId()));
        assertEquals(now, tuid2.getCreatedAt());
    }

    @Test
    public void tuidsAreUnique() {
        Integer count = 100000;
        // Generate IDs in series, ensuring that they are unique.
        SortedSet<String> sequential = Stream.generate(TUID::createId)
                .limit(count)
                .collect(Collectors.toCollection(TreeSet::new));
        assertEquals(count, sequential.size());
        // Generate IDs in parallel, ensuring that they are unique. A million IDs takes about a second.
        SortedSet<TUID> parallel = IntStream.range(0, count).unordered().parallel()
                .mapToObj(unused -> new TUID())
                .collect(Collectors.toCollection(TreeSet::new));
        assertEquals(count, parallel.size());
    }

    @Test
    public void tuidsAreValidated() {
        ZonedDateTime previousCentury = ZonedDateTime.of(1999, 12, 31, 23, 59, 59, 999999999, ZoneId.of("UTC"));
        assertFalse(TUID.isValidId(new TUID(previousCentury.toInstant()).getId()));
        ZonedDateTime nextCentury = ZonedDateTime.of(2100, 1, 1, 0, 0, 0, 1, ZoneId.of("UTC"));
        assertFalse(TUID.isValidId(new TUID(nextCentury.toInstant()).getId()));
        assertTrue(TUID.isValidId(TUID.MIN_ID));         // 2000-01-01T00:00:00Z
        assertTrue(TUID.isValidId(TUID.MAX_ID));         // 2100-01-01T00:00:00Z
        assertTrue(TUID.isValidId("91Mq07yx9IxHCi5Y"));  // 2021-03-08T05:54:09.208207Z
        assertTrue(TUID.isValidId("AndIHave16Digits"));  // 2031-04-10T08:19:33.665030998Z
        assertFalse(TUID.isValidId("BogusText"));        // insufficient digits
        assertFalse(TUID.isValidId("6447693"));          // an integer ID generated by some other system
        assertFalse(TUID.isValidId("I'mNotATuid!"));     // invalid characters
        assertFalse(TUID.isValidId(""));
        assertFalse(TUID.isValidId(null));
    }

    @Test
    public void bitLengthVaries() {
        // The bit length of a TUID varies depending on the embedded timestamp.
        assertEquals(92, new TUID(TUID.MIN_ID).bitLength());
        assertEquals(94, new TUID(TUID.MAX_ID).bitLength());
        // However, valid ID length is constant
        assertEquals(TUID.MIN_ID.length(), TUID.MAX_ID.length());
        assertEquals(16, TUID.MIN_ID.length());
    }

    @Test
    public void firstIdSortsBeforeId() {
        Instant now = Instant.now();
        TUID tuid = new TUID(now);
        TUID first = new TUID(TUID.firstId(now));
        assertTrue(first.compareTo(tuid) < 0);
        String id = tuid.getId();
        String firstId = first.getId();
        assertTrue(firstId.compareTo(id) < 0);
        String idBinary = tuid.bits();
        String firstIdBinary = first.bits();
        assertTrue(firstIdBinary.compareTo(idBinary) < 0);
        Integer idBitLength = tuid.bitLength();
        Integer firstIdBitLength = first.bitLength();
        assertEquals(idBitLength, firstIdBitLength);
        BigInteger idEntropy = tuid.entropy();
        BigInteger firstIdEntropy = first.entropy();
        assertEquals(BigInteger.ZERO, firstIdEntropy);
        assertNotEquals(idEntropy, firstIdEntropy);
    }

    @Test
    public void formattedTimestamp() {
        String id = "91Mq07yx9IxHCi5Y";
        TUID tuid = new TUID(id);
        String utcTimestamp = tuid.getCreatedAt().toString();
        assertEquals("2021-03-08T05:54:09.208207Z", utcTimestamp);
        String formatted = tuid.timestamp(TUID.TIME_ZONE, TUID.TIME_FORMATTER);
        assertEquals("Sun 03-07-2021 09:54:09 PT", formatted);
    }

    @Test
    public void formattedLocalDate() {
        String id = "91Mq07yx9IxHCi5Y";
        TUID tuid = new TUID(id);
        String utcLocalDate = tuid.localDate(ZoneId.of("UTC")).toString();
        assertEquals("2021-03-08", utcLocalDate);
        String pacificLocalDate = tuid.localDate(TUID.TIME_ZONE).toString();
        assertEquals("2021-03-07", pacificLocalDate);
    }

    @Test
    public void durationBetweenTuids() {
        ZonedDateTime ts1 = ZonedDateTime.of(2021, 5, 29, 16, 4, 32, 0, ZoneId.of("UTC"));
        ZonedDateTime ts2 = ZonedDateTime.of(2021, 5, 30, 20, 18, 16, 207000000, ZoneId.of("UTC"));
        TUID tuid1 = new TUID(ts1.toInstant());
        TUID tuid2 = new TUID(ts2.toInstant());
        Duration duration = tuid1.duration(tuid2);
        String isoFormat = duration.toString();
        assertEquals("PT28H13M44.207S", isoFormat);
        String formatted = tuid1.durationString(tuid2);
        assertEquals("1 d 04:13:44.207", formatted);
    }
}
